// Generated by dts-bundle v0.7.3
// Dependencies for this module:
//   ../../lodash/shuffle
//   ../../event-emitter

declare module 'richang' {
    import shuffle from "lodash/shuffle";
    import * as event from "richang/event/event";
    import * as stringify from "richang/stringify/stringify";
    import * as geometry from "richang/geometry/geometry";
    import * as object from "richang/object/object";
    import * as array from "richang/array/array";
    import * as gob from "richang/gob/gob";
    import * as url from "richang/url/url";
    import * as cache from "richang/cache/cache";
    import * as func from "richang/function/function";
    import * as async from "richang/async/async";
    import * as time from "richang/time/time";
    import * as number from "richang/number/number";
    import * as image from "richang/image/image";
    import * as binary from "richang/binary/binary";
    import * as string from "richang/string/string";
    import * as crypto from "richang/crypto/crypto";
    let Richang: {
        shuffle: {
            <T>(collection: ArrayLike<T> | null | undefined): T[];
            <T extends object>(collection: T | null | undefined): T[keyof T][];
        };
        event: typeof event;
        object: typeof object;
        array: typeof array;
        geometry: typeof geometry;
        stringify: typeof stringify;
        url: typeof url;
        func: typeof func;
        cache: typeof cache;
        async: typeof async;
        time: typeof time;
        number: typeof number;
        image: typeof image;
        binary: typeof binary;
        string: typeof string;
        crypto: typeof crypto;
        gob: typeof gob;
    };
    export { Richang, shuffle, event, geometry, object, array, stringify, url, cache, async, func, time, number, image, binary, string, crypto, gob };
}

declare module 'richang/event/event' {
    import EventEmitter from "event-emitter";
    /**
        * 监听关闭函数
        */
    type listenCloser = () => void;
    /**
        * 事件总线
        * 一个事件注册\监听管理器，提供 `on`、`off`、`emit` 等基本的事件模式必要的功能
        * 与一般事件模式工具的主要区别：
        * - 事件数据强制使用一个参数传递而不是任意数量参数（`emit('event', data)`），鼓励使用对象传递数据。
        * - 除了使用 `off` 来结束监听，每一次 `on` 时还会返回一个监听关闭函数，执行它会关闭这个监听。
        *
        * 注意：重复监听需要多次取消监听
        *
        * @example
        * ```
        *
        * let eventHub = new EventHub()
        * // 注册监听
        * let closer = eventHub.on("error", (e)=>{console.log(e)})
        * eventHub.emit("error", {errName:"oh!"})
        * // 关闭监听
        * closer()
        * ```
        */
    export class EventHub {
            eventEmitter: EventEmitter.Emitter;
            constructor();
            /**
                * 监听一个事件。
                * 会返回一个监听关闭函数，执行它会结束这个监听。
                *
                * @param typePath 事件类型，支持路径
                * @param listener 监听器
                * @param needlessCloser 不需要返回监听关闭函数
                * @return {listenCloser}
                */
            on(typePath: string, listener: (eventData: any) => void, needlessCloser?: boolean): listenCloser | undefined;
            /**
                * 取消监听一个事件
                * @param typePath 事件类型，支持路径
                * @param listener 监听器
                * @constructor
                */
            off(typePath: string, listener: (eventData: any) => void): void;
            /**
                * 清空全部监听器
                */
            offAll(): void;
            /**
                * 触发监听
                * @param typePath
                * @param eventData
                */
            emit(typePath: string, eventData?: any): void;
    }
    export {};
}

declare module 'richang/stringify/stringify' {
    /**
        * 把 Javascript 值转换到 JSON
        * 出错或输入 undefined 会返回 undefined
        * 使用 circularReappear 参数能够把使用 toJson() 记录的带闭环对象信息的 json 还原成一个闭环对象
        *
        * @param value
        * @param space
        * @param circularReappear
        * @return {string}
        */
    export function toJson(value: any, space?: number, circularReappear?: boolean): string | undefined;
    /**
        * 从 JSON 字符串反序列化为 Javascript 值
        * 出错或输入 undefined 会返回 undefined
        * 使用 circularReappear 参数能够把使用 toJson() 记录的带闭环对象信息的 json 还原成一个闭环对象
        *
        * @param value
        * @param circularReappear 闭环对象重现
        * @return {any}
        */
    export function fromJson(value: any, circularReappear?: boolean): any;
}

declare module 'richang/geometry/geometry' {
    import * as rect from "richang/geometry/lib/rect";
    export { rect };
}

declare module 'richang/object/object' {
    import { objectEach as _objectEach } from "richang/object/lib/objectEach";
    import { objectFilter as _objectFilter } from "richang/object/lib/objectFilter";
    import { objectRemove as _objectRemove } from "richang/object/lib/objectFilter";
    import { objectMask as _objectMask } from "richang/object/lib/objectFilter";
    export const objectFilter: typeof _objectFilter;
    export const objectEach: typeof _objectEach;
    export const objectRemove: typeof _objectRemove;
    export const objectMask: typeof _objectMask;
    export const isEqual: (value: any, other: any) => boolean;
    /**
        * 获取一个对象的 hash 值
        * @param object
        */
    export function getObjectHash(object: any): string;
    /**
        * 对象是否为空
        * @returns {boolean}
        * @param object
        */
    export function isEmptyObject(object: object): boolean;
    /**
        * 判断一个值是否是对象（可遍历键值）
        * 函数是对象，null 不是对象
        * @example
        * isObject(null) // false
        * isObject(()=>{})) // true
        * @param value
        * @return {boolean}
        */
    export function isObject(value: object): boolean;
    /**
        * 数组化键名路径
        */
    export type KeyPath = string[];
    /**
        * 规范化键名路径
        *
        * @example
        * normalizeKeyPath("foo.bar") // => ["foo","bar"]
        * normalizeKeyPath("foo/bar") // => ["foo","bar"]
        * normalizeKeyPath(["foo","bar"]) // => ["foo","bar"]
        *
        * @param inPath
        * @return {string[]}
        */
    export function normalizeKeyPath(inPath: string | string[]): KeyPath;
    /**
        * 比较 2 个键名路径是否相等。可以是数组形式的 keyPath 也可以是路径字符串
        * @param keyPathA
        * @param keyPathB
        * @return {boolean}
        */
    export function keyPathEqual(keyPathA: string | string[], keyPathB: string | string[]): boolean;
    /**
        * 根据键名路径获取对象值
        *
        * @param object 对象
        * @param path 键名路径
        * @return {any}
        */
    export function getObjectValueByPath(object: object, path: string | string[]): any;
    /**
        * 根据键名路径给对象赋值，成功返回 true
        * 当路径在目标对象中不存在时会自动创建对象，可以通过给 disableAutoMakeObject 传 true 来禁止这个机制
        *
        * @param object 对象
        * @param path 键名路径
        * @param value 值
        * @param overwrite 覆盖，当路径不存在或路径中存在不可赋值项时自动创建对象
        *
        * @example
        * let obj = {a:{b:1}}
        * setObjectValueByPath(a,"a.b",3) // obj => {a:{b:3}}
        * setObjectValueByPath(a,"a.b.d.e",5) // obj => {a:{b:{c:{d:5}}}}
        * @return {any}
        */
    export function setObjectValueByPath(object: object, path: string | string[], value: any, overwrite?: boolean): boolean;
    /**
        * 根据键名路径删除对象
        * @param object
        * @param path
        */
    export function deleteObjectValueByPath(object: object, path: string | string[]): boolean | undefined;
    /**
        * 深度克隆一个对象
        * @param object
        */
    export let cloneDeep: (obejct: any) => any;
    /**
        * @example
        * // 普通规则
        * {
        *     name:"user_name"
        *     id:"info.id"
        * }
        *
        * // 规则处理字符串的键名路径外还可以提供处理函数： [路径, 处理函数, 逆向处理函数]
        * {
        *     updateDate:["update_date", (x)=>{new Date(x)}, (x)=>{JSON.stringify(x)}]
        * }
        *
        */
    export interface IMappingRule {
            [key: string]: any | [string, Function, Function] | IMappingRule;
    }
    /**
        * 对象映射。
        * 通过定义的映射规则（mappingRule）把源对象转换成另一个新对象
        * 映射规则：定影新对象的结构，新对象中值根据映射规则中的“键名路径”从源对象获取
        * 映射规则
        *
        * @example
        * // 源对象
        * {
        *     user_name:"a",
        *     info:{
        *         id:123,
        *     }
        * }
        *
        * // 规则
        * {
        *     name:"user_name"
        *     id:"info.id"
        * }
        *
        *
        * // 新对象
        * {
        *     name:"a"
        *     id:123
        * }
        *
        * // 规则处理字符串的键名路径外还可以提供处理函数： [路径, 处理函数, 逆向处理函数]
        * {
        *     updateDate:["update_date", (x)=>{new Date(x)}, (x)=>{JSON.stringify(x)}]
        * }
        *
        * // 如果不提供的处理函数而是 undefined，产生的新对象将没有这个键
        * {
        *     updateDate:["update_date", (x)=>{new Date(x)}, undefined }]
        * }
        *
        * @param objectSource 原对象
        * @param mappingRule 映射规则
        * @param reverse 逆向映射
        * @return {any}
        */
    export function mappingObject(objectSource: any, mappingRule: IMappingRule, reverse?: boolean): any;
    /**
        * 深度合并多个对象， 相当于递归的 Object.assign()
        *
        * @param object
        * @param [sources]
        * @returns Returns `object`.
        * @example
        *
        * let users = {
        *   'data': [{ 'user': 'barney' }, { 'user': 'fred' }]
        * };
        *
        * let ages = {
        *   'data': [{ 'age': 36 }, { 'age': 40 }]
        * };
        *
        * assignDeep(users, ages);
        * // => { 'data': [{ 'user': 'barney', 'age': 36 }, { 'user': 'fred', 'age': 40 }] }
        */
    export const assignDeep: {
            <TObject, TSource>(object: TObject, source: TSource): TObject & TSource;
            <TObject, TSource1, TSource2>(object: TObject, source1: TSource1, source2: TSource2): TObject & TSource1 & TSource2;
            <TObject, TSource1, TSource2, TSource3>(object: TObject, source1: TSource1, source2: TSource2, source3: TSource3): TObject & TSource1 & TSource2 & TSource3;
            <TObject, TSource1, TSource2, TSource3, TSource4>(object: TObject, source1: TSource1, source2: TSource2, source3: TSource3, source4: TSource4): TObject & TSource1 & TSource2 & TSource3 & TSource4;
            (object: any, ...otherArgs: any[]): any;
    };
}

declare module 'richang/array/array' {
    /**
        *  对象比较方法
        *  - equal: boolean 内容比较
        *  - idKey: string id 比较，指定一个 key 作为对象的 id
        */
    export interface IObjectEqualMethod {
            equal?: boolean;
            idKey?: string;
    }
    /**
        * △ 数组求对称差
        * a:[1,2,3]  b:[1,2,4]  a△b => [3,4]
        *
        * （可选支持对象数组）
        * @example
        * a = [{key:1}, {key:2}]
        * b = [{key:2}, {key:3}]
        * arraySymDifference(a,b,{idKey:"key"}) => [{key:1},{key:3}]
        *
        *
        * @param a
        * @param b
        * @param equalMethod 对象比较方法，默认直接比较（===）, {equal:true}：比较对象内容; {idKey:"id"}：用对象的指定 key 作为 id 比较
        * @return {any}
        */
    export function arraySymDifference(a: any[], b: any[], equalMethod?: {
            equal?: boolean;
            idKey?: string;
    }): any;
    /**
        * ∪ 数组求对称差
        * a:[1,2,3]  b:[1,2,4]  a∪b => [1,2,3,4]
        * @param a
        * @param b
        * @param equalMethod
        * @return {any}
        */
    export function arrayUnion(a: any[], b: any[], equalMethod?: {
            equal?: boolean;
            idKey?: string;
    }): any;
    /**
        * ∩ 数组求交集
        * a:[1,2,3]  b:[1,2,4]   a ∩ b => [1,2]
        * @param a
        * @param b
        * @param equalMethod
        * @return {any}
        */
    export function arrayIntersection(a: any[], b: any[], equalMethod?: {
            equal?: boolean;
            idKey?: string;
    }): any;
    /**
        * - 数组集合相减
        * a:[1,2,3]  b:[1,2,4]   a - b => [3]
        * @param a
        * @param b
        * @param equalMethod
        * @return {any}
        */
    export function arraySubtract(a: any[], b: any[], equalMethod?: {
            equal?: boolean;
            idKey?: string;
    }): any;
}

declare module 'richang/gob/gob' {
    import { GobRecorder } from "richang/gob/recorder/recorder";
    import { IGobHandler } from "richang/gob/handlers/GobHandler";
    export class GobCore {
        gate: any;
        data: any;
        recorder: GobRecorder;
        handler: IGobHandler;
        constructor();
    }
    export function GobFactory(target: any): any;
}

declare module 'richang/url/url' {
    export function urlQueryToObject(urlQuery: string): any;
    export function objectToUrlQuery(object: any): string;
}

declare module 'richang/cache/cache' {
    interface ICacheItem {
        data: any;
        latestTimestamp: number;
        timestamp: number;
        visit: number;
    }
    export interface KeyValueCacheOptions {
        timeout?: number;
        disablRemoveTimeoutCache?: boolean;
    }
    /**
      * 键值对缓存
      */
    export class KeyValueCache<K, V> {
        caches: Map<K, ICacheItem>;
        options: KeyValueCacheOptions;
        constructor(options?: KeyValueCacheOptions);
        set(key: K, value: V): void;
        get(key: K, options?: KeyValueCacheOptions): any;
        has(key: K, options?: KeyValueCacheOptions): boolean;
    }
    export {};
}

declare module 'richang/function/function' {
    import { applyWithCache as _applyWithCache } from "richang/function/lib/applyWithCache";
    export const applyWithCache: typeof _applyWithCache;
    /**
      * 把一个函数变为一个可缓存的函数，在指定时间内触发相同调用（参数一致，深度比较）时不会真正执行而是直接返回上一次的缓存
      * @param func 函数
      * @param timeout 缓存过期时间 ms
      * @param thisArg 函数的 this ，与 apply 的一致
      */
    export function cacheable(func: Function, timeout: number, thisArg?: any): (...args: any[]) => any;
}

declare module 'richang/async/async' {
    /**
      * 异步延时
      * @param ms 毫秒
      */
    export function sleep(ms: number): Promise<{}>;
    import { Runner as _Runner } from "richang/async/lib/Runner";
    export const Runner: typeof _Runner;
}

declare module 'richang/time/time' {
    /**
        * 创建一个秒表函数，秒表函数每次执行会返回执行时到创建时的时差
        *
        * @example
        * let st = stopwatch()
        * await sleep(100)
        * st() // 100
        * await sleep(100)
        * st() // 200
        *
        * @return {() => number}
        */
    export function stopwatch(): () => number;
    /**
        * 生成时间戳
        *
        * @example
        * genTimestamp()    //=> 1521602474428
        * @return {number}
        */
    export function genTimestamp(): number;
    /**
        * 生成时间戳文本
        * @example
        * genTimestampText()  //=>  "JTJWZRH3"
        * @return {string}
        */
    export function genTimestampText(): string;
    /**
        * 从时间戳/时间戳文本解析出 Date 对象
        * @param timestamp
        * @return {Date}
        */
    export function parseTimestamp(timestamp: string | number): Date;
    type TimeUnitType = "millisecond" | "second" | "minute" | "hour" | "day" | "month" | "year" | "date";
    /**
        * 计算 2 个 Date 的时差
        * @param date
        * @param oldDate
        * @param unit 时差单位
        * @return {number}
        */
    export function timeDiff(date: Date, oldDate?: Date, unit?: TimeUnitType): number;
    /**
        * 计算 2 个 Date 的时差（天）
        * @param date
        * @param oldDate
        * @return {number}
        */
    export function timeDiffDay(date: Date, oldDate?: Date): number;
    /**
        * 计算 2 个 Date 的时差（分钟）
        * @param date
        * @param oldDate
        * @return {number}
        */
    export function timeDiffMinute(date: Date, oldDate?: Date): number;
    export {};
}

declare module 'richang/number/number' {
    /**
        * 检查一个数是否在范围内
        * @param inNum 要检查的数
        * @param range 范围数组 （如[0,1]）
        * @param openInterval 是否用开区间判断（即用 > 而不是默认的 >= ）
        * @return {boolean}
        */
    export function inRange(inNum: number, range: [number, number], openInterval?: boolean): boolean;
    /**
        * 数值归一化/标准化。把数值变为目标区间范围的数，默认为归一化（[0,1]）
        * @param inNum 原数
        * @param inRange 原数所在区间
        * @param [outRange] 目标区间
        * @return {number}
        */
    export function normaliz(inNum: number, inRange: [number, number], outRange?: [number, number]): number;
}

declare module 'richang/image/image' {
    /**
        * 根据 URL 获取一张图片，返回其 ImageData
        * @param url
        * @return {Promise<ImageData>}
        */
    export function fetchImageAsImageData(url: string): Promise<ImageData>;
    /**
        * 根据 URL 获取一张图片，返回 Image（HTMLImageElement）对象
        * @param url
        */
    export function fetchImage(url: string): Promise<HTMLImageElement>;
    /**
        * 把 ImageData 编码成二进制数据（Blob）
        *  ImageData 是包含图片像素数据数组和宽高信息的对象
        * @param data ImageData
        * @param type 图片格式如 image/gif, image/png, image/jpeg, image/webp
        * @param quality 质量参数 0~1（toDataURL 为 jpeg, webp 用的的质量参数）
        * @return {Promise<Blob>}
        */
    export function imageEncode(data: ImageData, type?: string, quality?: number): Promise<Blob>;
    /**
        * 图片解码把一个浏览器支持格式的图片 Blob 解码成 ImageData
        * @param imageBlob
        * @return {Promise<ImageData>}
        */
    export function imageDecode(imageBlob: Blob): Promise<ImageData>;
    /**
        * 检查一个图片 Blob 的格式，返回 MimeType
        * @param blob
        * @return {Promise<any>}
        */
    export function checkImageType(blob: Blob): Promise<string>;
    /**
        * 把图片的 Blob 转换为 Image 对象
        * @param blob
        * @return {Promise<HTMLImageElement>}
        */
    export function blobToImg(blob: Blob): Promise<HTMLImageElement>;
    /**
        * 把任何可绘制内容放到一个 canvas 里
        * @return {Promise<HTMLCanvasElement>}
        * @param canvas 指定 canvas ，默认会创建一个新 canvas
        * @param inDrawable
        */
    export function toCanvas(inDrawable: string | Blob | HTMLImageElement | ImageData | ImageBitmap, canvas?: HTMLCanvasElement): Promise<HTMLCanvasElement>;
    /**
        * 判断一个对象是否可当作 ImageData 用
        * @param object
        * @return {Promise<boolean>}
        */
    export function isImageData(object: any): boolean;
}

declare module 'richang/binary/binary' {
    import { downloadFile as _downloadFile } from "richang/binary/lib/downloadFile";
    export const downloadFile: typeof _downloadFile;
    import { getReadableByteSize as _getReadableByteSize } from "richang/binary/lib/helpers";
    export const getReadableByteSize: typeof _getReadableByteSize;
    /**
        * 把 uint8Array 转换为 dataURL
        * 当不再使用这个 URL 时，记得使用 URL.revokeObjectURL( url ) 释放内存
        * @param unit8Array
        * @param type
        * @return {string}
        */
    export function uint8ArrayToDataURL(unit8Array: Uint8Array | Uint8ClampedArray, type?: string): string;
    /**
        * 把一个文件转换为 ArrayBuffer
        * @param file
        * @return {Promise<any>}
        */
    export function fileToArrayBuffer(file: File | Blob): Promise<ArrayBuffer>;
    /**
        *  把一个 blob 转换为 ArrayBuffer
        * @param blob
        * @return {Promise<ArrayBuffer>}
        */
    export function blobToArrayBuffer(blob: Blob): Promise<ArrayBuffer>;
    /**
        * 把一个 blob 转换为 text
        * @param blob
        * @return {Promise<string>}
        */
    export function blobToText(blob: Blob): Promise<string>;
    /**
        * 把一个文件转换为 DataURL
        * @param file
        * @return {Promise<any>}
        */
    export function fileToDataURL(file: File | Blob): Promise<{}>;
    /**
        *  dataURL 转换到 Blob
        * @param dataURL
        */
    export function dataURLtoBlob(dataURL: string): Blob;
    /**
        * dataURL 转换到 Blob 的异步方法，理论上会更快
        * @param dataURL
        */
    export function dataURLtoBlobAsync(dataURL: string): Promise<Blob>;
    /**
        * 把 ArrayBuffer 转换为 Unit8Array
        * @param arrayBuufer
        * @return {Uint8Array}
        */
    export function arrayBufferToUint8Array(arrayBuufer: ArrayBuffer): Uint8Array;
    /**
        * 把 ArrayBuffer 转换为 Uint8ClampedArray
        * Uint8ClampedArray 与 Unit8Array 不同在于转换时小于 0 的数会转换为 0，大于 255 的数会转换为 255；而 Unit8Array 转换时是去掉符号位的结果（即补码结果）
        * @param arrayBuufer
        * @return {Uint8ClampedArray}
        */
    export function arrayBufferToUint8ClampedArray(arrayBuufer: ArrayBuffer): Uint8ClampedArray;
    /**
        * 把一个 ArrayBuffer, Uint8Array, dataURL 转换为一个 Blob
        */
    export function toBlob(data: ArrayBuffer | string, type?: string): Blob;
    /**
        * 异步的把一个 ArrayBuffer, Uint8Array, dataURL 转换为一个 Blob
        */
    export function toBlobAsync(data: ArrayBuffer | string, type?: string): Blob | Promise<Blob>;
    /**
        * 判断一个对象是否是 Blob
        * @param data
        */
    export function isBlob(data: any): boolean;
}

declare module 'richang/string/string' {
    /**
        * 把一段文本插入文本到指定位置
        * @param str
        * @param start
        * @param offset
        * @param inStr
        * @return {string}
        */
    export function stringInsert(str: string, start: number, offset: number, inStr: string): string;
    /**
        * 去除一个字符串中不合法字符，使其成为可用作文件名的字符串
        * @param text
        * @param fix 非法字符替代字，默认为空文本，即非法字符被移除
        * @return {string}
        */
    export function normailzeFileName(text: string, fix?: string): string;
}

declare module 'richang/crypto/crypto' {
    /**
        * 生成一个随机的 UUID
        *
        * genUUID_v4() => 'f8061fba-842b-4cc5-9872-9348e2e06916'
        * @return {string}
        */
    export function genUUID_v4(): string;
    /**
        * 根据一个名字和命名空间生成一个 UUID，这个 UUID 与名称+命名空间有一一对应，不随机
        * （与标准不同，这里命名空间可不用 UUID 而是任何字符串，我们会用默认 UUID 和给命名空间生成一个 UUID）
        * @param name
        * @param namespace UUID 或者任意字符串（）
        * @return {string}
        */
    export function genUUID_v5(name: string, namespace?: string): string;
    /**
        * 用 sha1 生成一个字符串
        *
        * @example
        * genSHA1("nullice") \\ => 51918a176c8e2b0af211a94c5478c58a54f239cd
        * @param str
        */
    export function genSHA1(str: string): string;
    /**
        * 把36位字符串转换成带横杠 UUID 的格式
        *
        * formatUUID("e9411a6f1a2e22dd2244b78ee491c616") => "e9411a6f1a2e22dd2244b78ee491c616"
        * @param {string}  str
        * @returns {string}
        */
    export function formatUUID(str: string): string;
    /**
        * 检查一个字符串是 UUID 的版本或者是否是 UUID，返回 UUID 的版本，如果为 0 则说明不是 UUID
        * @param uuid
        * @return {number}
        */
    export function checkUUID(uuid: string): number;
    /**
        * 生成一个随机整数
        * @param {number} max - 最大值
        * @param {number} min - 最小值
        * @return {number}
        */
    export function roll(max?: number, min?: number): number;
    /**
        * 生成一个随机字符串
        * @param {number} length - 随机字符串长度
        * @param {string} [dict] - 随机字符字典，默认为 a—Z0-9
        * @returns {string}
        */
    export function rollString(length: number, dict?: string): string;
}

declare module 'richang/geometry/lib/rect' {
    import { IXy } from "richang/geometry/lib/point";
    export interface IRltb {
            right: number;
            left: number;
            top: number;
            bottom: number;
    }
    export interface IXywh {
            x: number;
            y: number;
            w: number;
            h: number;
    }
    export type Rect = IRltb | IXywh;
    /**
        * 矩形描述转换
        * 把 {right, left, top, bottom} 转化为 {x, y , w, h}
        * @param rltb
        * @return {IXywh}
        */
    export function rltb2xywh(rltb: IRltb): IXywh;
    /**
        * 矩形描述转换
        * 把 {x, y , w, h} 转化为 {right, left, top, bottom}
        * @param xywh
        * @return {IRltb}
        */
    export function xywh2rltb(xywh: IXywh): IRltb;
    /**
        * 给 Rltb 添加内边距
        * @param rltb
        * @param padding 内边距，支持类似 CSS 的数组形式
        *
        * @example
        * paddingRltb(xywh, 5)
        * paddingRltb(xywh, [3,4,5,10])
        *
        * @return {IRltb}
        */
    export function paddingRltb(rltb: IRltb, padding: number | number[]): IRltb;
    /**
        * 给 Xywh 添加内边距
        * @param xywh
        * @param padding 内边距，支持类似 CSS 的数组形式
        *
        * @example
        * paddingXywh(xywh, 5)
        * paddingXywh(xywh, [3,4,5,10])
        */
    export function paddingXywh(xywh: IXywh, padding: number | number[]): IXywh;
    /**
        * 给 Rect 添加内边距
        * @param rect
        * @param padding 内边距，支持类似 CSS 的数组形式
        *
        * @example
        * paddingRect(xywh, 5)
        * paddingRect(rltb, [3,4,5,10])
        */
    export function paddingRect(rect: Rect, padding: number | number[]): Rect;
    /**
        * 矩形对象是否是 IXywh 的描述形式
        * @param rect
        */
    export function rectIsXywh(rect: Rect): boolean;
    /**
        * 矩形对象是否是 IRltb 的描述形式
        * @param rect
        */
    export function rectIsRltb(rect: Rect): boolean;
    /**
        * 计算多个 rltb 矩形的边界
        *
        * getRltbsRange([xywh])
        * @returns {IRltb}
        * @param rltbs
        */
    export function getRltbsRange(rltbs: IRltb[]): IRltb;
    /**
        * 计算多个 xywh 矩形的边界
        *
        * getXywhsRange([xywh])
        * @param xywhs
        * @returns {IRltb}
        */
    export function getXywhsRange(xywhs: IXywh[]): IRltb;
    /**
        * 整体移动多个 xywh 到某点，保留原 xywhs 相对位置。
        * 会改变 xywhs 里每个 xywh 对象的 x，y 值。
        * @param xywhs
        * @param xy
        * @return {IXywh[]}
        */
    export function moveXywhs(xywhs: IXywh[], xy: IXy): IXywh[];
    /**
        * 判断 2 个 rltb 是否有重叠
        * @param rltbA
        * @param rltbB
        * @returns {boolean}
        */
    export function rltbHasOverlap(rltbA: IRltb, rltbB: IRltb): boolean;
    /**
        * 判断 2 个 xywh 是否有重叠
        * @param xywhA
        * @param xywhB
        * @return {boolean}
        */
    export function xywhHasOverlap(xywhA: IXywh, xywhB: IXywh): boolean;
}

declare module 'richang/object/lib/objectEach' {
    export interface IObjectEachOptions {
            depthFirst?: boolean;
            /**
                *  深度遍历的回弹（出栈）遍历函数
                *  eachFunc 相当于在入栈时执行，而 depthReboundFunc 在出栈时执行
                *  执行时意味着所有子节点已经遍历完了
                *
                * @param value
                * @param key
                * @param info
                */
            depthReboundFunc?: (value: any, key: string, info: {
                    parent: any;
                    deep: number;
                    keyPath?: string[];
            }) => any;
            checkCycle?: boolean;
            /**
                * 循环依赖回调
                * @param value
                * @param key
                * @param parent
                * @param keyPath
                * @param firstPath 出现循环依赖的对象第一次出现的 keyPath
                */
            checkCycleCallback?: (value: any, key: string, info: {
                    parent: any;
                    keyPath?: string[];
                    firstKeyPath?: string[];
            }) => void;
            needKeyPath?: boolean;
            /**
             仅遍历指定 key 的 children
                * @example
                * {children:{
                *      item1:{value:1, children:{
                *             item2:{value:1}
                *      } }
                * }}
                */
            childrenKey?: string;
    }
    enum EachControl {
            exit = -1,
            break = -2,
            continue = -3
    }
    interface IEachControls {
            exit: EachControl.exit;
            break: EachControl.break;
            continue: EachControl.continue;
    }
    /**
        * 对象遍历, 遍历对象的每一个键
        *
        * @param object
        * @param eachFunc 遍历函数。返回 -1 时终止遍历（exit）；返回 -2 时终止当层遍历（break）; 返回 -3 跳到下一个遍历（continue）
        * @param options
        */
    export function objectEach(object: any, eachFunc: (value: any, key: string, info: {
            parent: any;
            deep: number;
            end: boolean;
            keyPath?: string[];
    }, CONTOL: IEachControls) => void | -1 | -2 | -3, options?: IObjectEachOptions): void;
    export {};
}

declare module 'richang/object/lib/objectFilter' {
    import { IObjectEachOptions } from "richang/object/lib/objectEach";
    /**
        * 过滤一个对象，提供过滤函数遍历对象每一个属性（会递归子对象），过滤函数返回真属性则保留。
        * 可以是变异原对象的也可以返回新对象
        * @param object
        * @param filterFunc 过滤函数，如果返回真，遍历的值将被保留否则被抛弃
        * @param mutation 是否修改对象本身。默认为否会返回新对象
        * @param eachOptions
        */
    export function objectFilter(object: any, filterFunc: (value: any, key: string, info: {
            parent: any;
            deep: number;
            end: boolean;
            keyPath?: string[];
    }) => boolean, mutation?: boolean, eachOptions?: IObjectEachOptions): any;
    /**
        * 从对象中删除拥有指定值的属性
        * @param obejct 对象
        * @param value 指定的值（会进行 === 比较）
        * @param mutation  是否修改对象本身。默认为否会返回新对象
        */
    export function objectRemove(obejct: any, value: any, mutation?: boolean): any;
    /**
        * 对象蒙版，把一个对象根据蒙版对象裁剪属性。源对象会变成和蒙版对象一样的结构。
        *
        *@example
        *
        * let obj ={a:5, b:5, c:{c1: 4, c2:4}}
        * let mask = {a:1, c:{c1:1}}
        * objectMask(obj, mask) // =>  {a:5, c:{c1:4}}
        *
        *
        * @param obejct 源对象
        * @param maskObject 蒙版对象
        * @param mutation 是否修改对象本身。默认为否会返回新对象
        * @return {any}
        */
    export function objectMask(obejct: any, maskObject: any, mutation?: boolean): any;
}

declare module 'richang/gob/recorder/recorder' {
    import { GobCore } from "richang/gob/gob";
    import { IGobOperator } from "richang/gob/operators/operator";
    /**
      * Gob 的操作录放器
      * 对 Gob 对象对操作通过 handler 转换为一个个 GobOperator ，而 GobRecorder 把 GobOperator 执行或者记录下来
      *
      */
    export class GobRecorder {
        gobCore: GobCore;
        memory: IGobOperatorMemory;
        constructor(gobCore: GobCore);
        push(): void;
    }
    export interface IGobOperatorMemory {
        changes: IGobOperator[];
        visits: IGobOperator[];
        indexes: {
            set: number;
            get: number;
            delete: number;
            all: number;
            [propName: string]: number;
        };
        latestOperator: IGobOperator | null;
    }
}

declare module 'richang/gob/handlers/GobHandler' {
    import { GobCore } from "richang/gob/gob";
    export interface IGobHandler {
        wrapData: (target: any, gobCore: GobCore, keyPath: string[], localData: any, localGate: any) => any;
        set: Function;
        get: Function;
        del: Function;
    }
}

declare module 'richang/function/lib/applyWithCache' {
    /**
      * 执行一个函数（类似 Function.apply），会记录缓存，相同函数相同参数多次执行会执行返回缓存结果，可以指定缓存过期时间
      * @param func
      * @param thisArg
      * @param args
      * @param cacheOptions
      * @return {any}
      */
    export function applyWithCache(func: Function, thisArg: any, args: any[], cacheOptions: {
        timeout?: number;
    }): any;
    export function functinCache(): void;
}

declare module 'richang/async/lib/Runner' {
    export interface IRunnerTask {
            id: number;
            timestamp: number;
            promise: Promise<any>;
            error?: any;
            isFailed?: boolean;
            isOver?: boolean;
    }
    interface IRunnerFunc {
            func: Function;
            args?: any[];
            thisArgs?: any;
    }
    type RunnerFuncSort = [Function, ...any[]];
    /**
        * 异步任务运行器选项
        * - timeout 超时时间
        */
    interface IRunnerOptions {
            timeout?: number;
    }
    /**
        * 异步任务运行器
        */
    export class Runner {
            running: IRunnerTask[];
            finally: IRunnerTask[];
            success: IRunnerTask[];
            failed: IRunnerTask[];
            track: number;
            taskLength: number;
            isPause: boolean;
            isRunning: boolean;
            taskPool: IRunnerFunc[];
            options: IRunnerOptions;
            /**
                * 运行多个异步函数（或非异步），可以控制同时运行任务的数量、超时时间、暂停、监听进度等操作
                *
                * @example
                * let runner = new Runner([ [sleep, 50], [sleep, 70] , [sleep, 200]], 2, { timeout: 500 })
                * runner.onProgress((precent, info, runner)=>{ console.log( precent +"%")})
                * await runner.run()
                *
                * @param taskFuncs 任务函数
                * @param track 同时运行任务数
                * @param options 选项
                * @param options.timeout 超时时间（单个任务）
                */
            constructor(taskFuncs?: Function[] | IRunnerFunc[] | RunnerFuncSort[], track?: number, options?: {
                    timeout?: number;
            });
            /**
                * 监听每一个任务开始的事件
                * 会返回一个监听关闭函数，执行它会结束这个监听。
                * @param callback
                * @returns {() => void}
                */
            onTaskStart(callback: (task: IRunnerTask, runner: Runner) => void): (() => void) | undefined;
            /**
                * 监听每一个任务结束的事件，成功与失败都会执行
                * 会返回一个监听关闭函数，执行它会结束这个监听。
                * @param callback
                * @returns {() => void}
                */
            onTaskFinal(callback: (task: IRunnerTask, runner: Runner) => void): (() => void) | undefined;
            /**
                * 监听任务进度
                * @example
                * runner.onProgress((precent: number, info: { current: number; max: number }, runner: Runner)=>{
                *    precent      // 99 （当前进度百分比）
                *    info.current // 990（当前任务数）
                *    info.max     // 1000（最大任务数）
                * })
                *
                * @param callback
                * @return {() => void}
                */
            onProgress(callback: (precent: number, info: {
                    current: number;
                    max: number;
            }, runner: Runner) => void): (() => void) | undefined;
            /**
                * 运行任务池中的任务
                * @return {Promise<any>}
                */
            run(): Promise<{}>;
            /**
                * 暂停
                */
            pause(): void;
            /**
                * 继续
                */
            resume(): void;
            /**
                * 添加任务到任务池
                * @param taskFunc
                */
            add(taskFunc: Function | Function[] | IRunnerFunc | IRunnerFunc[] | RunnerFuncSort | RunnerFuncSort[]): void;
            /**
                * 清空全部任务与状态
                */
            clear(): void;
    }
    export {};
}

declare module 'richang/binary/lib/downloadFile' {
    /**
      * 调用一个浏览器下载一个 File 或者 Blob
      * @param file
      * @param name
      */
    export function downloadFile(file: File | Blob, name?: string): void;
}

declare module 'richang/binary/lib/helpers' {
    /**
      * 把字节长度用为可读性强的单位表示
      * @param byteLength
      * @returns {string}
      * @example
      * getReadableFileSize(100)  // "100 B"
      * getReadableFileSize(1024) // "1.00 KB"
      * getReadableFileSize(4553) // "4.45 KB"
      * getReadableFileSize(2240000) // "2.14 MB"
      * getReadableFileSize(999888777660) // "931.22 GB"
      */
    export function getReadableByteSize(byteLength: number): string;
}

declare module 'richang/geometry/lib/point' {
    export interface IXy {
        x: number;
        y: number;
    }
    export type Point = IXy;
    /**
      * 获取 2 点间距离
      * @param p1
      * @param p2
      * @return {number}
      */
    export function get2PointDistance(p1: Point, p2: Point): number;
}

declare module 'richang/gob/operators/operator' {
    export enum GobOperatorType {
        get = "get",
        set = "set",
        delete = "delete"
    }
    export interface IGobOperator {
        type: GobOperatorType;
        keyPath: string[];
        value: any;
        origin: null | any;
    }
}

